"use strict";(self.webpackChunkelcengine=self.webpackChunkelcengine||[]).push([[6619],{4158:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>l,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var n=s(4848),i=s(8453);const r={sidebar_position:6},c="Type Inference",o={id:"getting-started/type-inference",title:"Type Inference",description:"Due to the nature and limitations of Go, Elemental cannot provide you with the level of automatic type inference that you might see in a language such as TypeScript.",source:"@site/docs/getting-started/type-inference.md",sourceDirName:"getting-started",slug:"/getting-started/type-inference",permalink:"/docs/getting-started/type-inference",draft:!1,unlisted:!1,editUrl:"https://github.com/elcengine/elcengine.github.io/tree/main/docs/docs/getting-started/type-inference.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"docSidebar",previous:{title:"Create a Model",permalink:"/docs/getting-started/create-a-model"},next:{title:"Basic Operations",permalink:"/docs/category/basic-operations"}},a={},d=[];function h(e){const t={code:"code",h1:"h1",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"type-inference",children:"Type Inference"}),"\n",(0,n.jsx)(t.p,{children:"Due to the nature and limitations of Go, Elemental cannot provide you with the level of automatic type inference that you might see in a language such as TypeScript."}),"\n",(0,n.jsxs)(t.p,{children:["As you might have noticed, almost all Elemental queries end with the ",(0,n.jsx)(t.code,{children:"Exec()"})," method which returns an ",(0,n.jsx)(t.code,{children:"interface{}"}),". Thefore you need to use a type assertion to convert the result to the expected type in your code."]}),"\n",(0,n.jsxs)(t.p,{children:["That being said, manual type assertion is still a pain and we want to make it as easy as possible for you to work with Elemental. To achieve this, Elemental provides a couple of helper methods in place of ",(0,n.jsx)(t.code,{children:"Exec()"})," to get typed results from your queries."]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"ExecT()"})," - Executes the query and returns the result as the generic type ",(0,n.jsx)(t.code,{children:"T"})," which was passed to the model. This method is useful for queries that return a single document such as ",(0,n.jsx)(t.code,{children:"Create()"})]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"ExecPtr()"})," - Executes the query and returns the result as a pointer to the generic type ",(0,n.jsx)(t.code,{children:"T"})," which was passed to the model. This method is useful for queries that return a single document or nothing, such as ",(0,n.jsx)(t.code,{children:"FindOne()"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"ExecTT()"})," - Executes the query and returns the result as a slice of the generic type ",(0,n.jsx)(t.code,{children:"T"})," which was passed to the model. This method is useful for queries that return multiple documents such as ",(0,n.jsx)(t.code,{children:"Find()"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"ExecTP()"})," - Executes the query and returns the result as a ",(0,n.jsx)(t.code,{children:"PaginateResult"})," of the generic type ",(0,n.jsx)(t.code,{children:"T"})," which was passed to the model. This method is useful for paginated queries."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"ExecInt()"})," - Executes the query and returns the result as an ",(0,n.jsx)(t.code,{children:"int"}),". This method is useful for queries that return a single integer value, such as count queries or schedule queries which return a cron entry ID."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"ExecSS()"})," - Executes the query and returns the result as a slice of strings. This method is useful for queries that return an array of strings, such as distinct queries."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"ExecInto()"})," - Executes the query and unmarshals the result into the provided result variable. It is useful when you want to extract results into a custom struct other than the model type such as when you populate certain fields."]}),"\n"]}),"\n"]})]})}function l(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>c});var n=s(6540);const i={},r=n.createContext(i);function c(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}}}]);